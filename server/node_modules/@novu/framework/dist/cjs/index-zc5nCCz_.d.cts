import { g as ClientOptions, W as Workflow, H as HealthCheck, k as DiscoverOutput, p as Event, t as ExecuteOutput, f as CodeResult, m as EventTriggerParams, ae as Awaitable, S as Schema, a as FromSchema, F as FromSchemaUnvalidated, ap as Execute, at as WorkflowOptions } from './health-check.types-DjxZf7gi.cjs';

declare class Client {
    private discoveredWorkflows;
    private discoverWorkflowPromises;
    private templateEngine;
    secretKey: string;
    apiUrl: string;
    version: string;
    strictAuthentication: boolean;
    constructor(options?: ClientOptions);
    private buildOptions;
    /**
     * Adds workflows to the client.
     *
     * A locking mechanism is used to ensure that duplicate workflows are not added.
     *
     * @param workflows - The workflows to add.
     */
    addWorkflows(workflows: Array<Workflow>): Promise<void>;
    private addWorkflow;
    healthCheck(): HealthCheck;
    private getWorkflow;
    private getStep;
    private getRegisteredWorkflows;
    discover(): DiscoverOutput;
    /**
     * Mocks data based on the given schema.
     * The `default` value in the schema is used as the base data.
     * If no `default` value is provided, the data is generated using JSONSchemaFaker.
     *
     * @param schema
     * @returns mocked data
     */
    private mock;
    private validate;
    private throwInvalidProvider;
    private throwInvalidStep;
    private throwInvalidEvent;
    private executeStepFactory;
    private shouldSkip;
    executeWorkflow(event: Event): Promise<ExecuteOutput>;
    private createExecutionPayload;
    private prettyPrintExecute;
    private executeProviders;
    private previewProvider;
    private executeProvider;
    private executeStep;
    private compileControls;
    /**
     * Create the controls for a step, taking both the event controls and the default controls into account
     *
     * @param step The step to create the controls for
     * @param event The event that triggered the step
     * @returns The controls for the step
     */
    private createStepControls;
    private previewStep;
    private constructStepForPreview;
    private extractMockDataForPreviousSteps;
    private previewRequiredStep;
    private getStepState;
    private getStepCode;
    private getWorkflowCode;
    getCode(workflowId: string, stepId?: string): CodeResult;
}

type ServeHandlerOptions = {
    client?: Client;
    workflows: Array<Workflow>;
};
type INovuRequestHandlerOptions<Input extends any[] = any[], Output = any> = ServeHandlerOptions & {
    frameworkName: string;
    client?: Client;
    workflows: Array<Workflow>;
    handler: Handler<Input, Output>;
};
type Handler<Input extends any[] = any[], Output = any> = (...args: Input) => HandlerResponse<Output>;
type HandlerResponse<Output = any> = {
    body: () => Awaitable<any>;
    headers: (key: string) => Awaitable<string | null | undefined>;
    method: () => Awaitable<string>;
    queryString?: (key: string, url: URL) => Awaitable<string | null | undefined>;
    url: () => Awaitable<URL>;
    transformResponse: (res: IActionResponse<string>) => Output;
};
type IActionResponse<TBody extends string = string> = {
    status: number;
    headers: Record<string, string>;
    body: TBody;
};
declare class NovuRequestHandler<Input extends any[] = any[], Output = any> {
    readonly frameworkName: string;
    readonly handler: Handler<Input, Output>;
    readonly client: Client;
    private readonly hmacEnabled;
    private readonly http;
    private readonly workflows;
    constructor(options: INovuRequestHandlerOptions<Input, Output>);
    createHandler(): (...args: Input) => Promise<Output>;
    private getStaticHeaders;
    private createResponse;
    private createError;
    private handleAction;
    private getPostActionMap;
    triggerAction(triggerEvent: EventTriggerParams): () => Promise<IActionResponse<string>>;
    private getGetActionMap;
    private handlePostAction;
    private handleGetAction;
    private handleError;
    private validateHmac;
}

/**
 * Define a new notification workflow.
 */
declare function workflow<T_PayloadSchema extends Schema, T_ControlSchema extends Schema, T_PayloadValidated extends Record<string, unknown> = FromSchema<T_PayloadSchema>, T_PayloadUnvalidated extends Record<string, unknown> = FromSchemaUnvalidated<T_PayloadSchema>, T_Controls extends Record<string, unknown> = FromSchema<T_ControlSchema>>(workflowId: string, execute: Execute<T_PayloadValidated, T_Controls>, workflowOptions?: WorkflowOptions<T_PayloadSchema, T_ControlSchema>): Workflow<T_PayloadUnvalidated>;

export { Client as C, type INovuRequestHandlerOptions as I, NovuRequestHandler as N, type ServeHandlerOptions as S, workflow as w };
