import { S as Schema, F as FromSchemaUnvalidated, a as FromSchema, J as JsonSchema, P as PostActionEnum } from '../health-check.types-DjxZf7gi.js';
export { B as ActionStep, A as ActionStepEnum, ae as Awaitable, o as CancelEventTriggerResponse, ar as ChannelPreference, K as ChannelStep, d as ChannelStepEnum, X as ChatOutput, Y as ChatOutputUnvalidated, _ as ChatResult, g as ClientOptions, f as CodeResult, ag as ConditionalPartial, C as CronExpression, I as CustomStep, am as DeepPartial, an as DeepRequired, a2 as DelayOutput, a3 as DelayOutputUnvalidated, a4 as DelayResult, a9 as DigestOutput, aa as DigestOutputUnvalidated, a5 as DigestRegularOutput, a6 as DigestRegularOutputUnvalidated, ab as DigestResult, a7 as DigestTimedOutput, a8 as DigestTimedOutputUnvalidated, k as DiscoverOutput, D as DiscoverProviderOutput, i as DiscoverStepOutput, j as DiscoverWorkflowOutput, E as Either, L as EmailOutput, M as EmailOutputUnvalidated, N as EmailResult, p as Event, m as EventTriggerParams, n as EventTriggerResponse, l as EventTriggerResult, ap as Execute, ao as ExecuteInput, t as ExecuteOutput, r as ExecuteOutputMetadata, s as ExecuteOutputOptions, G as GetActionEnum, H as HealthCheck, $ as InAppOutput, a0 as InAppOutputUnvalidated, a1 as InAppResult, ah as Indexable, x as JobStatusEnum, ai as PickOptional, al as PickOptionalKeys, aj as PickRequired, ak as PickRequiredKeys, af as Prettify, T as PushOutput, U as PushOutputUnvalidated, V as PushResult, v as Skip, O as SmsOutput, Q as SmsOutputUnvalidated, R as SmsResult, q as State, ac as Step, y as StepContext, w as StepOptions, z as StepOutput, h as StepType, ad as Subscriber, W as Workflow, e as WorkflowChannelEnum, at as WorkflowOptions, aq as WorkflowPreference, as as WorkflowPreferences, u as ZodSchema, Z as ZodSchemaMinimal, b as actionStepSchemas, c as channelStepSchemas } from '../health-check.types-DjxZf7gi.js';
export { S as SupportedFrameworkName } from '../server.types-BRWsA1CA.js';
import { ValidateFunction as ValidateFunction$1 } from 'ajv';
import { ParseReturnType } from 'zod';
import '@novu/shared';
import 'json-schema-to-ts';

declare enum NovuApiEndpointsEnum {
    SYNC = "/v1/bridge/sync",
    DIFF = "/v1/bridge/diff"
}
declare const SIGNATURE_TIMESTAMP_TOLERANCE_MINUTES = 5;
declare const SIGNATURE_TIMESTAMP_TOLERANCE: number;

declare enum ErrorCodeEnum {
    BRIDGE_ERROR = "BridgeError",
    EXECUTION_EVENT_CONTROL_INVALID_ERROR = "ExecutionEventControlInvalidError",
    EXECUTION_EVENT_PAYLOAD_INVALID_ERROR = "ExecutionEventPayloadInvalidError",
    EXECUTION_PROVIDER_OUTPUT_INVALID_ERROR = "ExecutionProviderOutputInvalidError",
    EXECUTION_STATE_CONTROL_INVALID_ERROR = "ExecutionStateControlInvalidError",
    EXECUTION_STATE_CORRUPT_ERROR = "ExecutionStateCorruptError",
    EXECUTION_STATE_OUTPUT_INVALID_ERROR = "ExecutionStateOutputInvalidError",
    EXECUTION_STATE_RESULT_INVALID_ERROR = "ExecutionStateResultInvalidError",
    INVALID_ACTION_ERROR = "InvalidActionError",
    METHOD_NOT_ALLOWED_ERROR = "MethodNotAllowedError",
    MISSING_DEPENDENCY_ERROR = "MissingDependencyError",
    MISSING_SECRET_KEY_ERROR = "MissingSecretKeyError",
    PROVIDER_EXECUTION_FAILED_ERROR = "ProviderExecutionFailedError",
    PROVIDER_NOT_FOUND_ERROR = "ProviderNotFoundError",
    SIGNATURE_EXPIRED_ERROR = "SignatureExpiredError",
    SIGNATURE_INVALID_ERROR = "SignatureInvalidError",
    SIGNATURE_MISMATCH_ERROR = "SignatureMismatchError",
    SIGNATURE_NOT_FOUND_ERROR = "SignatureNotFoundError",
    SIGNATURE_VERSION_INVALID_ERROR = "SignatureVersionInvalidError",
    SIGNING_KEY_NOT_FOUND_ERROR = "SigningKeyNotFoundError",
    STEP_ALREADY_EXISTS_ERROR = "StepAlreadyExistsError",
    STEP_CONTROL_COMPILATION_FAILED_ERROR = "StepControlCompilationFailedError",
    STEP_EXECUTION_FAILED_ERROR = "StepExecutionFailedError",
    STEP_NOT_FOUND_ERROR = "StepNotFoundError",
    WORKFLOW_ALREADY_EXISTS_ERROR = "WorkflowAlreadyExistsError",
    WORKFLOW_NOT_FOUND_ERROR = "WorkflowNotFoundError",
    WORKFLOW_PAYLOAD_INVALID_ERROR = "WorkflowPayloadInvalidError"
}

declare enum HttpHeaderKeysEnum {
    NOVU_SIGNATURE = "novu-signature",
    NOVU_ANONYMOUS = "novu-anonymous",
    NOVU_FRAMEWORK_SDK = "novu-framework-sdk",
    NOVU_FRAMEWORK_SERVER = "novu-framework-server",
    NOVU_FRAMEWORK_VERSION = "novu-framework-version",
    USER_AGENT = "user-agent",
    CONTENT_TYPE = "content-type",
    ACCESS_CONTROL_ALLOW_ORIGIN = "access-control-allow-origin",
    ACCESS_CONTROL_ALLOW_METHODS = "access-control-allow-methods",
    ACCESS_CONTROL_ALLOW_HEADERS = "access-control-allow-headers",
    ACCESS_CONTROL_MAX_AGE = "access-control-max-age"
}

declare enum HttpMethodEnum {
    POST = "POST",
    GET = "GET",
    OPTIONS = "OPTIONS"
}

declare enum HttpQueryKeysEnum {
    WORKFLOW_ID = "workflowId",
    STEP_ID = "stepId",
    ACTION = "action",
    SOURCE = "source"
}

declare enum HttpStatusEnum {
    CONTINUE = 100,
    SWITCHING_PROTOCOLS = 101,
    PROCESSING = 102,
    EARLYHINTS = 103,
    OK = 200,
    CREATED = 201,
    ACCEPTED = 202,
    NON_AUTHORITATIVE_INFORMATION = 203,
    NO_CONTENT = 204,
    RESET_CONTENT = 205,
    PARTIAL_CONTENT = 206,
    AMBIGUOUS = 300,
    MOVED_PERMANENTLY = 301,
    FOUND = 302,
    SEE_OTHER = 303,
    NOT_MODIFIED = 304,
    TEMPORARY_REDIRECT = 307,
    PERMANENT_REDIRECT = 308,
    BAD_REQUEST = 400,
    UNAUTHORIZED = 401,
    PAYMENT_REQUIRED = 402,
    FORBIDDEN = 403,
    NOT_FOUND = 404,
    METHOD_NOT_ALLOWED = 405,
    NOT_ACCEPTABLE = 406,
    PROXY_AUTHENTICATION_REQUIRED = 407,
    REQUEST_TIMEOUT = 408,
    CONFLICT = 409,
    GONE = 410,
    LENGTH_REQUIRED = 411,
    PRECONDITION_FAILED = 412,
    PAYLOAD_TOO_LARGE = 413,
    URI_TOO_LONG = 414,
    UNSUPPORTED_MEDIA_TYPE = 415,
    REQUESTED_RANGE_NOT_SATISFIABLE = 416,
    EXPECTATION_FAILED = 417,
    I_AM_A_TEAPOT = 418,
    MISDIRECTED = 421,
    UNPROCESSABLE_ENTITY = 422,
    FAILED_DEPENDENCY = 424,
    PRECONDITION_REQUIRED = 428,
    TOO_MANY_REQUESTS = 429,
    INTERNAL_SERVER_ERROR = 500,
    NOT_IMPLEMENTED = 501,
    BAD_GATEWAY = 502,
    SERVICE_UNAVAILABLE = 503,
    GATEWAY_TIMEOUT = 504,
    HTTP_VERSION_NOT_SUPPORTED = 505
}

declare enum ResourceEnum {
    WORKFLOW = "workflow",
    PROVIDER = "provider",
    STEP = "step"
}

type ImportRequirement = {
    /**
     * The name of the dependency.
     *
     * This is a necessary duplicate as ESM does not provide a consistent API for
     * reading the name of a dependency that can't be resolved.
     *
     * @example
     * ```typescript
     * 'module-name'
     * ```
     */
    name: string;
    /**
     * The import statement for the required dependency. An explicit `import('module-name')`
     * call with a static module string is necessary to ensure that the bundler will make
     * the dependency available for usage after tree-shaking. Without a static string,
     * tree-shaking may aggressively remove the import, making it unavailable.
     *
     * This syntax is required during synchronous declaration (e.g. on a class property),
     * but should only be awaited when you can handle a runtime import error.
     *
     * @example
     * ```typescript
     * import('module-name')
     * ```
     */
    import: Promise<{
        default: unknown;
    } & Record<string, unknown>>;
    /**
     * The required exports of the dependency. The availability of these exports are
     * checked by the import validator to verify the dependency is installed.
     *
     * @example
     * ```typescript
     * ['my-export']
     * ```
     */
    exports: readonly string[];
};

type ValidateFunction<T = unknown> = ValidateFunction$1<T> | ((data: T) => ParseReturnType<T>);
type ValidationError = {
    path: string;
    message: string;
};
type ValidateResult<T> = {
    success: false;
    errors: ValidationError[];
} | {
    success: true;
    data: T;
};
type Validator<T_Schema extends Schema = Schema> = {
    validate: <T_Unvalidated extends Record<string, unknown> = FromSchemaUnvalidated<T_Schema>, T_Validated extends Record<string, unknown> = FromSchema<T_Schema>>(data: T_Unvalidated, schema: T_Schema) => Promise<ValidateResult<T_Validated>>;
    canHandle: (schema: Schema) => Promise<boolean>;
    transformToJsonSchema: (schema: T_Schema) => Promise<JsonSchema>;
    requiredImports: readonly ImportRequirement[];
};

/**
 * Check if the object is a native error.
 *
 * This method relies on `Object.prototype.toString()` behavior. It is possible to obtain
 * an incorrect result when the object argument has a non `Error`-suffixed `name` property.
 *
 * @param object - The object to check.
 * @returns `true` if the object is a native error, `false` otherwise.
 */
declare const isNativeError: (object: unknown) => object is Error;
/**
 * Base error class.
 */
declare abstract class FrameworkError extends Error {
    /**
     * HTTP status code.
     */
    abstract readonly statusCode: HttpStatusEnum;
    /**
     * Additional data that can be used to provide more information about the error.
     */
    data?: unknown;
    /**
     * The error code, which is used to identify the error type.
     */
    abstract readonly code: ErrorCodeEnum;
}
declare abstract class NotFoundError extends FrameworkError {
    statusCode: HttpStatusEnum;
}
declare abstract class BadRequestError extends FrameworkError {
    statusCode: HttpStatusEnum;
}
declare abstract class UnauthorizedError extends FrameworkError {
    statusCode: HttpStatusEnum;
}
declare abstract class ServerError extends FrameworkError {
    data: {
        /**
         * The stack trace of the error.
         */
        stack: string;
    };
    constructor(message: string, { cause }?: Partial<{
        cause: unknown;
    }>);
}
declare abstract class ConflictError extends FrameworkError {
    statusCode: HttpStatusEnum;
}
declare abstract class ForbiddenError extends FrameworkError {
    statusCode: HttpStatusEnum;
}

/**
 * A `BridgeError` is an unexpected error that occurs within the Bridge application.
 *
 * This error is used to wrap unknown errors that occur within the Bridge application,
 * such as errors due to unsupported runtime environments.
 */
declare class BridgeError extends ServerError {
    statusCode: HttpStatusEnum;
    code: ErrorCodeEnum;
    constructor(cause: unknown);
}

declare class ExecutionStateCorruptError extends BadRequestError {
    code: ErrorCodeEnum;
    constructor(workflowId: string, stepId: string);
}
declare class ExecutionEventPayloadInvalidError extends BadRequestError {
    code: ErrorCodeEnum;
    constructor(workflowId: string, data: unknown);
}
declare class ExecutionEventControlsInvalidError extends BadRequestError {
    code: ErrorCodeEnum;
    constructor(workflowId: string, data: unknown);
}
declare class ExecutionStateControlsInvalidError extends BadRequestError {
    code: ErrorCodeEnum;
    constructor(workflowId: string, stepId: string, data: unknown);
}
declare class ExecutionStateOutputInvalidError extends BadRequestError {
    code: ErrorCodeEnum;
    constructor(workflowId: string, stepId: string, data: unknown);
}
declare class ExecutionStateResultInvalidError extends BadRequestError {
    code: ErrorCodeEnum;
    constructor(workflowId: string, stepId: string, data: unknown);
}
declare class StepControlCompilationFailedError extends BadRequestError {
    code: ErrorCodeEnum;
    constructor(workflowId: string, stepId: string, data: unknown);
}
declare class ExecutionProviderOutputInvalidError extends BadRequestError {
    code: ErrorCodeEnum;
    constructor(workflowId: string, stepId: string, providerId: string, data: unknown);
}
declare class WorkflowPayloadInvalidError extends BadRequestError {
    code: ErrorCodeEnum;
    constructor(workflowId: string, data: unknown);
}

declare class MethodNotAllowedError extends FrameworkError {
    code: ErrorCodeEnum;
    statusCode: HttpStatusEnum;
    message: string;
}
declare class InvalidActionError extends BadRequestError {
    code: ErrorCodeEnum;
    constructor(action: string, allowedActions: Object);
}
declare class MissingSecretKeyError extends BadRequestError {
    code: ErrorCodeEnum;
    constructor();
}

declare class PlatformError extends Error {
    /**
     * HTTP status code.
     */
    statusCode: HttpStatusEnum;
    /**
     * Additional data that can be used to provide more information about the error.
     */
    data: unknown;
    code: ErrorCodeEnum;
    constructor(statusCode: HttpStatusEnum, code: string, message: string);
}

declare abstract class ResourceConflictError extends ConflictError {
    constructor(resource: ResourceEnum, id: string);
}
declare abstract class ResourceNotFoundError extends NotFoundError {
    constructor(resource: ResourceEnum, id: string);
}
declare abstract class ResourceExecutionFailed extends ServerError {
    statusCode: HttpStatusEnum;
    constructor(resource: ResourceEnum, id: string, action: PostActionEnum, cause: unknown);
}

declare class ProviderNotFoundError extends ResourceNotFoundError {
    code: ErrorCodeEnum;
    constructor(id: string);
}
declare class ProviderExecutionFailedError extends ResourceExecutionFailed {
    code: ErrorCodeEnum;
    constructor(id: string, action: PostActionEnum, cause: unknown);
}

declare class SignatureMismatchError extends UnauthorizedError {
    code: ErrorCodeEnum;
    constructor();
}
declare class SignatureNotFoundError extends UnauthorizedError {
    code: ErrorCodeEnum;
    constructor();
}
declare class SignatureInvalidError extends UnauthorizedError {
    code: ErrorCodeEnum;
    constructor();
}
declare class SignatureExpiredError extends UnauthorizedError {
    code: ErrorCodeEnum;
    constructor();
}
declare class SigningKeyNotFoundError extends UnauthorizedError {
    code: ErrorCodeEnum;
    constructor();
}
declare class SignatureVersionInvalidError extends UnauthorizedError {
    code: ErrorCodeEnum;
    constructor();
}

declare class StepNotFoundError extends ResourceNotFoundError {
    code: ErrorCodeEnum;
    constructor(id: string);
}
declare class StepAlreadyExistsError extends ResourceConflictError {
    code: ErrorCodeEnum;
    constructor(id: string);
}
declare class StepExecutionFailedError extends ResourceExecutionFailed {
    code: ErrorCodeEnum;
    constructor(id: string, action: PostActionEnum, cause: unknown);
}

declare class WorkflowNotFoundError extends ResourceNotFoundError {
    code: ErrorCodeEnum;
    constructor(id: string);
}
declare class WorkflowAlreadyExistsError extends ResourceConflictError {
    code: ErrorCodeEnum;
    constructor(id: string);
}

/**
 * Check if the error is a `FrameworkError`.
 *
 * A `FrameworkError` is an error thrown by the Framework.
 *
 * @param error - The error to check.
 * @returns `true` if the error is a `FrameworkError`, `false` otherwise.
 */
declare const isFrameworkError: (error: unknown) => error is FrameworkError;

export { BadRequestError, BridgeError, ConflictError, ErrorCodeEnum, ExecutionEventControlsInvalidError, ExecutionEventPayloadInvalidError, ExecutionProviderOutputInvalidError, ExecutionStateControlsInvalidError, ExecutionStateCorruptError, ExecutionStateOutputInvalidError, ExecutionStateResultInvalidError, ForbiddenError, FrameworkError, FromSchema, FromSchemaUnvalidated, HttpHeaderKeysEnum, HttpMethodEnum, HttpQueryKeysEnum, HttpStatusEnum, InvalidActionError, JsonSchema, MethodNotAllowedError, MissingSecretKeyError, NotFoundError, NovuApiEndpointsEnum, PlatformError, PostActionEnum, ProviderExecutionFailedError, ProviderNotFoundError, ResourceConflictError, ResourceEnum, ResourceExecutionFailed, ResourceNotFoundError, SIGNATURE_TIMESTAMP_TOLERANCE, SIGNATURE_TIMESTAMP_TOLERANCE_MINUTES, Schema, ServerError, SignatureExpiredError, SignatureInvalidError, SignatureMismatchError, SignatureNotFoundError, SignatureVersionInvalidError, SigningKeyNotFoundError, StepAlreadyExistsError, StepControlCompilationFailedError, StepExecutionFailedError, StepNotFoundError, UnauthorizedError, type ValidateFunction, type ValidateResult, type ValidationError, type Validator, WorkflowAlreadyExistsError, WorkflowNotFoundError, WorkflowPayloadInvalidError, isFrameworkError, isNativeError };
